#!/usr/bin/env python3

TOP = 10


debcounter = {}
scoreboard = {}


#parse
with open(".cache/Contents-amd64") as f:
    borkedlines = 0
    for lineno, line in enumerate(f, start=1):
        columns = line.strip().rsplit(maxsplit=1)

        # Quietly ignore malformed lines (per spec)
        if len(columns) != 2:
            borkedlines += 1
            continue

        path, locations = columns[0], columns[1]

        # Ignore optional header (per spec)
        if lineno == 1 and path == 'FILE' and locations == 'LOCATION':
            continue

        # Packages may be qualified with area/section names
        qdebs = [longname.split('/') for longname in locations.split(',')]
        max_qualifier_depth = max([len(qdeb) for qdeb in qdebs])

        # Ignore line with too many slashes in a qualified name (per spec)
        if max_qualifier_depth > 3:
            borkedlines += 1
            continue

        # Now we're sure everything's fine
        for qdeb in qdebs:
            deb = qdeb[-1]
            debcounter[deb] = debcounter.get(deb, 0) + 1


#get top
for deb, counter in debcounter.items():
    if counter not in scoreboard:
        scoreboard[counter] = []
    scoreboard[counter].append(deb)

topdebs = []
for score in sorted(scoreboard.keys(), reverse=True)[:TOP]:
    place = len(topdebs)+1
    if place > TOP:
        break
    debs = sorted(scoreboard[score])
    for deb in debs:
        topdebs.append((place, deb, score))

#print
for place, deb, score in topdebs:
    print("{}. {}\t\t\t{}".format(place, deb, score))


